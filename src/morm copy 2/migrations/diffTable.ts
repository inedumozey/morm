// migrations/diffTable.ts

import { buildDefaultSQL } from "../sql/buildDefaultSQL.js";
import { buildColumnSQL } from "../sql/buildColumnSQL.js";
import { colors } from "../utils/logColors.js";
import { canonicalType } from "../utils/canonicalType.js";

function normalizeDefault(d: string | null | undefined) {
  if (d == null) return null;
  let s = String(d).trim().toLowerCase();
  while (s.startsWith("(") && s.endsWith(")")) s = s.slice(1, -1).trim();
  s = s.replace(/'([^']*)'::[a-z_]+/g, "$1");
  s = s.replace(/::[a-z_]+$/g, "");
  return s.trim();
}

function normalizeModelDefault(def: any): string | null {
  if (def === undefined || def === null) return null;
  if (typeof def === "string") {
    const d = def.trim().toLowerCase();
    if (d === "uuid()") return "gen_random_uuid";
    if (d === "now()") return "current_timestamp";
    return normalizeDefault(d);
  }
  if (Array.isArray(def)) return JSON.stringify(def);
  return String(def);
}

function q(n: string) {
  return '"' + n.replace(/"/g, '""') + '"';
}

async function batchCounts(client: any, table: string, cols: string[]) {
  try {
    const parts = cols.map((c) => "count(" + q(c) + ") as " + q(c)).join(", ");
    const sql = "SELECT count(*) as total, " + parts + " FROM " + q(table);
    const r = await client.query(sql);
    const row = r.rows[0];
    const total = Number(row.total || 0);
    const nonNull: Record<string, number> = {};
    cols.forEach((c) => (nonNull[c] = Number(row[c] || 0)));
    return { total, nonNull };
  } catch {
    return null;
  }
}

/* ───────────────────────────────────────────── */
/* diffTable */
/* ───────────────────────────────────────────── */

export async function diffTable(
  client: any,
  config: { table: string },
  processed: any[],
  options?: { clean?: boolean; reset?: boolean }
) {
  const res = await client.query(
    `
    SELECT column_name, data_type, udt_name, is_nullable, column_default, is_identity
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND LOWER(table_name)=LOWER($1)
    `,
    [config.table]
  );

  type Row = {
    column_name: string;
    data_type: string;
    udt_name: string;
    is_nullable: string;
    column_default: string | null;
    is_identity: string;
  };

  const existing = new Map<string, Row>(
    res.rows.map((r: Row) => [r.column_name, r])
  );

  const alters: string[] = [];
  const messages: string[] = [];

  const modelNames = processed.map((c) => c.name);
  const existingNames = Array.from(existing.keys());
  const counts = await batchCounts(client, config.table, existingNames);

  /* ───────── RENAME DETECTION ───────── */

  const missingInModel = existingNames.filter((n) => !modelNames.includes(n));
  const missingInDB = modelNames.filter((n) => !existing.has(n));
  const modelMap = new Map(processed.map((c) => [c.name, c]));

  for (const oldName of missingInModel) {
    const old = existing.get(oldName);
    if (!old) continue;

    const cands = missingInDB.filter(
      (n) =>
        canonicalType(modelMap.get(n)?.type) === canonicalType(old.data_type)
    );

    if (cands.length === 1) {
      const nn = cands[0];
      alters.push(`RENAME COLUMN ${q(oldName)} TO ${q(nn)}`);
      messages.push(
        colors.cyan + "Renamed column " + oldName + " -> " + nn + colors.reset
      );
      existing.delete(oldName);
      existing.set(nn, old);
      const mc = modelMap.get(nn);
      if (mc) mc.__renamed = true;
    }
  }

  /* ───────── MAIN LOOP ───────── */

  for (const col of processed) {
    if (col.__virtual) continue;

    const name = col.name;
    const row = existing.get(name);

    // NEW COLUMN
    if (!row) {
      if (col.__renamed) continue;

      if (col.__identity) {
        alters.push(
          "ADD COLUMN " + q(name) + " INTEGER GENERATED BY DEFAULT AS IDENTITY"
        );
        messages.push(
          colors.green + "Added identity column " + name + colors.reset
        );
        continue;
      }

      const sql = buildColumnSQL(col);
      if (sql) alters.push("ADD COLUMN " + sql);
      messages.push(colors.green + "Added column " + name + colors.reset);
      continue;
    }

    // TYPE CHANGE
    const desired = canonicalType(col.type);
    const existingType =
      row.data_type === "USER-DEFINED"
        ? canonicalType(row.udt_name)
        : canonicalType(row.data_type);

    if (desired !== existingType) {
      const nonNullCount = counts?.nonNull[name] ?? 0;
      if (nonNullCount === 0) {
        alters.push(
          `ALTER COLUMN ${q(name)} TYPE ${desired} USING NULL::${desired}`
        );
        messages.push(
          `${colors.cyan}Changed type "${name}" → ${desired}${colors.reset}`
        );
      } else {
        messages.push(
          `${colors.yellow}Skipped type-change "${name}" (has data)${colors.reset}`
        );
      }
    }

    // NULLABILITY
    const modelNN = col.notNull !== false;
    const dbNN = row.is_nullable === "NO";
    if (modelNN !== dbNN) {
      const nonNull = counts?.nonNull[name] || 0;
      const total = counts?.total || 0;
      const nulls = total - nonNull;
      if (modelNN && nulls === 0) {
        alters.push("ALTER COLUMN " + q(name) + " SET NOT NULL");
        messages.push(colors.magenta + "Set NOT NULL " + name + colors.reset);
      } else if (!modelNN) {
        alters.push("ALTER COLUMN " + q(name) + " DROP NOT NULL");
        messages.push(
          colors.magenta + "Dropped NOT NULL " + name + colors.reset
        );
      } else {
        messages.push(
          colors.yellow +
            "Skipped NOT NULL " +
            name +
            " (NULLs exist)" +
            colors.reset
        );
      }
    }

    // DEFAULT
    if (row.is_identity !== "YES") {
      const modelNorm = normalizeModelDefault(col.default);
      const dbNorm = normalizeDefault(row.column_default);
      if (modelNorm !== dbNorm) {
        const defSQL = buildDefaultSQL(col);
        if (defSQL === null) {
          alters.push(`ALTER COLUMN ${q(name)} DROP DEFAULT`);
          messages.push(
            `${colors.green}Dropped DEFAULT for "${name}"${colors.reset}`
          );
        } else {
          alters.push(`ALTER COLUMN ${q(name)} SET DEFAULT ${defSQL}`);
          messages.push(
            `${colors.green}Set DEFAULT for "${name}"${colors.reset}`
          );
        }
      }
    }

    existing.delete(name);
  }

  /* ───────── DROP STALE ───────── */

  for (const name of existing.keys()) {
    if (!options?.clean) {
      messages.push(
        colors.yellow + "Skipped drop " + name + " (clean:false)" + colors.reset
      );
      continue;
    }

    const nonNull = counts?.nonNull[name] || 0;
    if (nonNull === 0) {
      alters.push("DROP COLUMN " + q(name));
      messages.push(
        colors.green + "Dropped empty column " + name + colors.reset
      );
    } else {
      messages.push(
        colors.yellow + "Skipped drop " + name + " (has data)" + colors.reset
      );
    }
  }

  /* ───────── APPLY (FIXED ORDER) ───────── */

  if (alters.length > 0) {
    const clean = alters.map((a) => a.trim()).filter(Boolean);

    // 1) RENAME COLUMN — MUST BE ALONE
    const renames = clean.filter((a) => /^RENAME COLUMN/i.test(a));
    for (const r of renames) {
      try {
        await client.query("ALTER TABLE " + q(config.table) + " " + r + ";");
      } catch (e: any) {
        console.error(
          colors.red +
            colors.bold +
            "MORM MIGRATION ERROR applying column-rename: " +
            colors.reset
        );
        console.error(colors.red + e.message + colors.reset);
        return null;
      }
    }

    // remove renames from further processing
    const rest = clean.filter((a) => !/^RENAME COLUMN/i.test(a));

    // 2) ADD COLUMN — one-by-one
    const addCols = rest.filter((a) => /^ADD COLUMN/i.test(a));
    for (const add of addCols) {
      try {
        await client.query("ALTER TABLE " + q(config.table) + " " + add + ";");
      } catch (e: any) {
        console.error(
          colors.red +
            colors.bold +
            "MORM MIGRATION ERROR applying column-add: " +
            colors.reset
        );
        console.error(colors.red + e.message + colors.reset);
        return null;
      }
    }

    // 3) EVERYTHING ELSE — comma-joined
    const others = rest.filter((a) => !/^ADD COLUMN/i.test(a));
    if (others.length > 0) {
      try {
        await client.query(
          "ALTER TABLE " + q(config.table) + " " + others.join(", ") + ";"
        );
      } catch (e: any) {
        console.error(
          colors.red +
            colors.bold +
            "MORM MIGRATION ERROR applying alterations: " +
            colors.reset
        );
        console.error(colors.red + e.message + colors.reset);
        return null;
      }
    }
  }

  return messages;
}

// CLEAN + STABLE diffTable.ts — SAFE MIGRATOR
// No accidental drops, correct type-changes, correct defaults, correct identity, correct enums.
// No $ inside template literals to avoid tool escaping issues.

import { buildColumnSQL } from "../sql/buildColumnSQL.js";
import { colors } from "../utils/logColors.js";

function canonicalType(t: string | null | undefined): string {
  if (!t) return "";
  const raw = String(t).trim().toUpperCase();
  const map: Record<string, string> = {
    INT: "INTEGER",
    INTEGER: "INTEGER",
    INT4: "INTEGER", // ← ADD THIS
    SERIAL: "INTEGER", // ← ADD THIS
    BIGSERIAL: "BIGINT", // ← ADD THIS
    SMALLINT: "SMALLINT",
    BIGINT: "BIGINT",
    TEXT: "TEXT",
    UUID: "UUID",
    BOOLEAN: "BOOLEAN",
    JSON: "JSON",
    JSONB: "JSONB",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMPTZ: "TIMESTAMPTZ",
    DATE: "DATE",
    TIME: "TIME",
    TIMEZ: "TIMEZ",
    NUMERIC: "NUMERIC",
    DECIMAL: "DECIMAL",
  };

  return map[raw] || raw;
}

function normalizeDefault(d: string | null | undefined) {
  if (d == null) return null;
  let s = String(d).trim().toLowerCase();
  while (s.startsWith("(") && s.endsWith(")")) s = s.slice(1, -1).trim();
  s = s.replace(/'([^']*)'::[a-z_]+/g, "$1");
  s = s.replace(/::[a-z_]+$/g, "");
  return s.trim();
}

function q(n: string) {
  return '"' + n.replace(/"/g, '""') + '"';
}

async function batchCounts(client: any, table: string, cols: string[]) {
  try {
    const parts = cols.map((c) => "count(" + q(c) + ") as " + q(c)).join(", ");
    const sql = "SELECT count(*) as total, " + parts + " FROM " + q(table);
    const r = await client.query(sql);
    const row = r.rows[0];
    const total = Number(row.total || 0);
    const nonNull: Record<string, number> = {};
    cols.forEach((c) => (nonNull[c] = Number(row[c] || 0)));
    return { total, nonNull };
  } catch {
    return null;
  }
}

export async function diffTable(
  client: any,
  config: { table: string },
  processed: any[],
  options?: { clean?: boolean; reset?: boolean }
) {
  const res = await client.query(
    "SELECT column_name, data_type, udt_name, is_nullable, column_default, is_identity FROM information_schema.columns WHERE table_schema = " +
      "'public'" +
      " AND LOWER(table_name)=LOWER($1)",
    [config.table]
  );

  type Row = {
    column_name: string;
    data_type: string;
    udt_name: string;
    is_nullable: string;
    column_default: string | null;
    is_identity: string;
  };

  const existing = new Map<string, Row>(
    res.rows.map((r: Row) => [r.column_name, r])
  );
  const alters: string[] = [];
  const messages: string[] = [];

  // AUTO‑ADD TIMESTAMPTZ created_at / updated_at
  const hasCreated = processed.some((c) => c.name === "created_at");
  const hasUpdated = processed.some((c) => c.name === "updated_at");

  if (!hasCreated) {
    processed.push({
      name: "created_at",
      type: "TIMESTAMPTZ",
      notNull: true,
      default: "now()",
    });
  }
  if (!hasUpdated) {
    processed.push({
      name: "updated_at",
      type: "TIMESTAMPTZ",
      notNull: true,
      default: "now()",
    });
  }

  const modelNames = processed.map((c) => c.name);
  const existingNames = Array.from(existing.keys());

  const counts = await batchCounts(client, config.table, existingNames);

  // RENAME DETECTION (simple: type matches)
  const missingInModel = existingNames.filter((n) => !modelNames.includes(n));
  const missingInDB = modelNames.filter((n) => !existing.has(n));
  const modelMap = new Map(processed.map((c) => [c.name, c]));

  for (const oldName of missingInModel) {
    const old = existing.get(oldName);
    if (!old) continue;
    const cands = missingInDB.filter(
      (n) =>
        canonicalType(modelMap.get(n)?.type) === canonicalType(old.data_type)
    );
    if (cands.length === 1) {
      const nn = cands[0];
      alters.push("RENAME COLUMN " + q(oldName) + " TO " + q(nn));
      messages.push(
        colors.cyan + "Renamed column " + oldName + " -> " + nn + colors.reset
      );
      existing.delete(oldName);
      existing.set(nn, old);
      missingInDB.splice(missingInDB.indexOf(nn), 1);
      const mc = modelMap.get(nn);
      if (mc) mc.__renamed = true;
    }
  }

  // MAIN LOOP
  for (const col of processed) {
    const name = col.name;
    const row = existing.get(name);

    // NEW COLUMN
    if (!row) {
      if (col.__renamed) continue;

      // int() => identity
      if (col.default === "int()") {
        alters.push(
          "ADD COLUMN " + q(name) + " INTEGER GENERATED BY DEFAULT AS IDENTITY"
        );
        messages.push(
          colors.green + "Added identity column " + name + colors.reset
        );
        continue;
      }

      // normal add
      alters.push("ADD COLUMN " + buildColumnSQL(col));
      messages.push(colors.green + "Added column " + name + colors.reset);
      continue;
    }

    // ------------------ TYPE CHANGE (diagnostic + robust equality) ------------------
    {
      const desired = canonicalType(col.type);

      // gather DB-reported types to compare (data_type and udt_name)
      const dbDataType = String(row.data_type ?? "").toUpperCase();
      const dbUdtName = String(row.udt_name ?? "").toUpperCase();

      // canonicalize both
      const dbTypeFromDataType = canonicalType(dbDataType);
      const dbTypeFromUdt = canonicalType(dbUdtName);

      // If any DB-candidate canonical type equals desired, treat as NO CHANGE
      if (dbTypeFromDataType === desired || dbTypeFromUdt === desired) {
        // nothing to do for type change — avoid accidental ALTER (especially for PK)
        existing.delete(name);
        continue;
      }

      // fallback existingType for older logic (kept for record)
      const existingType =
        row.data_type === "USER-DEFINED"
          ? canonicalType(row.udt_name ?? "")
          : canonicalType(row.data_type);

      // now existingType is different from desired — proceed with your earlier robust logic
      if (desired !== existingType) {
        const nonNullCount = counts?.nonNull[name] ?? 0;
        const usingNullCast = `NULL::${desired}`;

        // PRIMARY KEY handling
        if (col.__primary) {
          if (nonNullCount === 0) {
            const pkName = `${config.table}_pkey`;
            alters.push(`DROP CONSTRAINT IF EXISTS ${q(pkName)}`);
            alters.push(
              `ALTER COLUMN ${q(name)} TYPE ${desired} USING ${usingNullCast}`
            );
            alters.push(`ADD PRIMARY KEY (${q(name)})`);
            messages.push(
              `${colors.cyan}Changed primary key type "${name}" → ${desired} (column empty)${colors.reset}`
            );
            existing.delete(name);
            continue;
          }

          messages.push(
            `${colors.yellow}Skipped type-change for primary key "${name}" (contains data)${colors.reset}`
          );
          existing.delete(name);
          continue;
        }

        // NON-PRIMARY columns:
        if (nonNullCount === 0) {
          alters.push(
            `ALTER COLUMN ${q(name)} TYPE ${desired} USING ${usingNullCast}`
          );
          messages.push(
            `${colors.cyan}Changed type "${name}" → ${desired} (column empty)${colors.reset}`
          );
        } else {
          messages.push(
            `${colors.yellow}Skipped type-change "${name}" → ${desired} (column has data)${colors.reset}`
          );
          existing.delete(name);
          continue;
        }
      }
    }

    // NULLABILITY
    const modelNN = !!col.notNull;
    const dbNN = row.is_nullable === "NO";
    if (modelNN !== dbNN) {
      const nonNull = counts?.nonNull[name] || 0;
      const total = counts?.total || 0;
      const nulls = total - nonNull;
      if (modelNN && nulls === 0) {
        alters.push("ALTER COLUMN " + q(name) + " SET NOT NULL");
        messages.push(colors.magenta + "Set NOT NULL " + name + colors.reset);
      } else if (!modelNN) {
        alters.push("ALTER COLUMN " + q(name) + " DROP NOT NULL");
        messages.push(
          colors.magenta + "Dropped NOT NULL " + name + colors.reset
        );
      } else {
        messages.push(
          colors.yellow +
            "Skipped NOT NULL " +
            name +
            " (NULLs exist)" +
            colors.reset
        );
      }
    }

    // DEFAULT
    // DEFAULT HANDLING
    if (row.is_identity !== "YES") {
      let rawDefault = col.default ?? null;
      let mdef = rawDefault;
      const dbdef = row.column_default;

      // --- uuid() ---
      if (
        typeof rawDefault === "string" &&
        rawDefault.trim().toLowerCase() === "uuid()"
      ) {
        mdef = "gen_random_uuid()";
      }

      // --- int() => identity ---
      if (
        typeof rawDefault === "string" &&
        rawDefault.trim().toLowerCase() === "int()"
      ) {
        // Only add identity if column is NOT already identity
        if (row.is_identity !== "YES") {
          alters.push(
            `ALTER COLUMN ${q(name)} ADD GENERATED BY DEFAULT AS IDENTITY`
          );
          messages.push(
            `${colors.green}Set auto-increment on "${name}"${colors.reset}`
          );
        }
        continue;
      }

      // Normalize for comparison
      const nModel = normalizeDefault(mdef);
      const nDb = normalizeDefault(dbdef);

      if (nModel !== nDb) {
        if (mdef === null) {
          alters.push(`ALTER COLUMN ${q(name)} DROP DEFAULT`);
          messages.push(
            `${colors.green}Dropped DEFAULT ${name}${colors.reset}`
          );
        } else {
          alters.push(`ALTER COLUMN ${q(name)} SET DEFAULT ${mdef}`);
          messages.push(`${colors.green}Set DEFAULT ${name}${colors.reset}`);
        }
      }
    }

    existing.delete(name);
  }

  // DROP STALE
  for (const name of existing.keys()) {
    if (!options?.clean) {
      messages.push(
        colors.yellow + "Skipped drop " + name + " (clean:false)" + colors.reset
      );
      continue;
    }

    const nonNull = counts?.nonNull[name] || 0;
    if (nonNull === 0) {
      alters.push("DROP COLUMN " + q(name));
      messages.push(
        colors.green + "Dropped empty column " + name + colors.reset
      );
    } else {
      messages.push(
        colors.yellow + "Skipped drop " + name + " (has data)" + colors.reset
      );
    }
  }

  // APPLY — SAFE ORDERING
  if (alters.length > 0) {
    const clean = alters.map((a) => a.trim()).filter((a) => a.length > 0);
    if (clean.length > 0) {
      const addCols = clean.filter((a) => /^ADD COLUMN/i.test(a));
      for (const add of addCols) {
        try {
          await client.query(
            "ALTER TABLE " + q(config.table) + " " + add + ";"
          );
        } catch (e: any) {
          console.error(
            colors.red +
              colors.bold +
              "MORM MIGRATION ERROR applying column-add: " +
              colors.reset
          );
          console.error(colors.red + e.message + colors.reset);
          return null;
        }
      }
      const others = clean.filter((a) => !/^ADD COLUMN/i.test(a));
      if (others.length > 0) {
        const stmt =
          "ALTER TABLE " + q(config.table) + " " + others.join(", ") + ";";
        try {
          await client.query(stmt);
        } catch (e: any) {
          console.error(
            colors.red +
              colors.bold +
              "MORM MIGRATION ERROR applying alterations: " +
              colors.reset
          );
          console.error(colors.red + e.message + colors.reset);
          return null;
        }
      }
    }
  }

  return messages;
}
